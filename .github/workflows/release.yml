name: ğŸš€ Release Pipeline

on:
  push:
    branches:
      - main
      - master
    tags:
      - 'v*'  # Still support manual version tags
  pull_request:
    types: [closed]
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: false
        default: ''
      prerelease:
        description: 'Mark as pre-release'
        required: false
        default: false
        type: boolean
      force_release:
        description: 'Force release even if no changes'
        required: false
        default: false
        type: boolean

env:
  GODOT_VERSION: 4.4.1
  EXPORT_NAME: Children_of_Singularity

jobs:
  # Generate version and check if release is needed
  version-check:
    name: ğŸ·ï¸ Version Check
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.check.outputs.is_prerelease }}
    steps:
      - name: ğŸ“¥ Checkout Source
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: ğŸ” Check Release Conditions
        id: check
        run: |
          echo "ğŸ” Checking if release should be triggered..."

          SHOULD_RELEASE="false"
          IS_PRERELEASE="false"

          # Manual workflow dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.force_release }}" = "true" ] || [ -n "${{ github.event.inputs.version }}" ]; then
              SHOULD_RELEASE="true"
              echo "âœ… Manual release triggered"
            fi
          fi

          # Tag push
          if [ "${{ github.event_name }}" = "push" ]; then
            case "${{ github.ref }}" in
              refs/tags/v*)
                SHOULD_RELEASE="true"
                echo "âœ… Tag-based release triggered"
                ;;
            esac
          fi

          # PR merge to main/master
          if [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.action }}" = "closed" ] && [ "${{ github.event.pull_request.merged }}" = "true" ]; then
            # Check if PR has release-related changes
            echo "ğŸ” Checking PR for release-worthy changes..."

            # Get list of changed files
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }})
            echo "Changed files: $CHANGED_FILES"

            # Check for significant changes (not just docs or minor fixes)
            if echo "$CHANGED_FILES" | grep -E '\.(gd|tscn|tres|cs|cpp|h)$|scripts/|scenes/|assets/|project\.godot|export_presets\.cfg'; then
              SHOULD_RELEASE="true"
              IS_PRERELEASE="true"
              echo "âœ… PR contains significant changes, triggering release"
            else
              echo "â„¹ï¸ PR contains only minor changes, skipping release"
            fi
          fi

          # Push to main/master (direct commits)
          if [ "${{ github.event_name }}" = "push" ]; then
            case "${{ github.ref }}" in
              refs/heads/*)
                # Check if push contains significant changes
                echo "ğŸ” Checking push for release-worthy changes..."

            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
            echo "Changed files: $CHANGED_FILES"

            if echo "$CHANGED_FILES" | grep -E '\.(gd|tscn|tres|cs|cpp|h)$|scripts/|scenes/|assets/|project\.godot|export_presets\.cfg'; then
              SHOULD_RELEASE="true"
              IS_PRERELEASE="true"
              echo "âœ… Push contains significant changes, triggering release"
            else
              echo "â„¹ï¸ Push contains only minor changes, skipping release"
            fi
                ;;
            esac
          fi

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT

      - name: ğŸ·ï¸ Generate Version
        id: version
        run: |
          echo "ğŸ·ï¸ Generating version number..."

          # Use manual version if provided
          if [ -n "${{ github.event.inputs.version }}" ]; then
            VERSION="${{ github.event.inputs.version }}"
            echo "ğŸ“‹ Using manual version: $VERSION"
          else
            case "${{ github.ref }}" in
              refs/tags/v*)
                # Use tag version
                VERSION="${{ github.ref_name }}"
                echo "ğŸ“‹ Using tag version: $VERSION"
                ;;
              *)
                # Generate automatic version
            BRANCH_NAME="${{ github.ref_name }}"
            BUILD_NUMBER="${{ github.run_number }}"
            COMMIT_SHORT="${{ github.sha }}"
            COMMIT_SHORT=$(echo "$COMMIT_SHORT" | cut -c1-8)
            TIMESTAMP=$(date +%Y%m%d)

            # Get latest tag for base version
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            echo "ğŸ“‹ Latest tag: $LATEST_TAG"

            # Extract version numbers using portable method
            VERSION_NUMBERS=$(echo "$LATEST_TAG" | sed 's/^v//' | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' || echo "")
            if [ -n "$VERSION_NUMBERS" ]; then
              MAJOR=$(echo "$VERSION_NUMBERS" | cut -d. -f1)
              MINOR=$(echo "$VERSION_NUMBERS" | cut -d. -f2)
              PATCH=$(echo "$VERSION_NUMBERS" | cut -d. -f3)
            else
              MAJOR=0
              MINOR=1
              PATCH=0
            fi

            # Auto-increment based on branch
            if [ "$BRANCH_NAME" = "main" ] || [ "$BRANCH_NAME" = "master" ]; then
              # Increment patch for main branch
              PATCH=$((PATCH + 1))
              VERSION="v${MAJOR}.${MINOR}.${PATCH}-build.${BUILD_NUMBER}"
            else
              # Use current version with build suffix for other branches
              VERSION="v${MAJOR}.${MINOR}.${PATCH}-${BRANCH_NAME}.${BUILD_NUMBER}"
            fi

            echo "ğŸ“‹ Generated version: $VERSION"
                ;;
            esac
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ğŸ“‹ Final version: $VERSION"

  # Build the game for all platforms
  build-game:
    name: ğŸ® Build Game
    runs-on: ubuntu-latest
    needs: version-check
    if: needs.version-check.outputs.should_release == 'true'
    container:
      image: barichello/godot-ci:4.4.1
    steps:
      - name: ğŸ“¥ Checkout Source
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: ğŸ“‹ Setup Build Environment
        run: |
          echo "ğŸ”§ Setting up build environment..."
          echo "Version: ${{ needs.version-check.outputs.version }}"
          echo "Build Number: ${{ github.run_number }}"
          echo "Commit: ${{ github.sha }}"
          mkdir -v -p ~/.local/share/godot/export_templates/
          mv /root/.local/share/godot/export_templates/${GODOT_VERSION}.stable ~/.local/share/godot/export_templates/${GODOT_VERSION}.stable

      - name: ğŸ–¥ï¸ Build for Windows
        run: |
          echo "ğŸ–¥ï¸ Building for Windows..."
          mkdir -v -p build/windows
          godot --headless --verbose --export-release "Windows Desktop" build/windows/$EXPORT_NAME.exe

      - name: ğŸ Build for macOS
        run: |
          echo "ğŸ Building for macOS..."
          mkdir -v -p build/macos
          godot --headless --verbose --export-release "macOS" build/macos/$EXPORT_NAME.zip

      - name: ğŸ§ Build for Linux
        run: |
          echo "ğŸ§ Building for Linux..."
          mkdir -v -p build/linux
          godot --headless --verbose --export-release "Linux/X11" build/linux/$EXPORT_NAME.x86_64

      - name: ğŸ“ Copy Additional Files
        run: |
          echo "ğŸ“ Copying additional files..."
          for platform in windows macos linux; do
            if [ -d "build/$platform" ]; then
              cp README.md build/$platform/ 2>/dev/null || echo "âš ï¸ README.md not found"
              cp LICENSE build/$platform/ 2>/dev/null || echo "âš ï¸ LICENSE not found"
            fi
          done

      - name: ğŸ“¦ Create Release Archives
        run: |
          echo "ğŸ“¦ Creating release archives..."
          cd build

          # Get version from tag or input
          VERSION="${{ needs.version-check.outputs.version }}"
          echo "ğŸ“‹ Version: $VERSION"

          # Windows - ZIP archive
          if [ -d "windows" ]; then
            echo "ğŸ“¦ Creating Windows archive..."
            cd windows
            zip -r "../${EXPORT_NAME}_${VERSION}_Windows.zip" .
            cd ..
          fi

          # macOS - ZIP archive
          if [ -d "macos" ]; then
            echo "ğŸ“¦ Creating macOS archive..."
            cd macos
            zip -r "../${EXPORT_NAME}_${VERSION}_macOS.zip" .
            cd ..
          fi

          # Linux - TAR.GZ archive
          if [ -d "linux" ]; then
            echo "ğŸ“¦ Creating Linux archive..."
            cd linux
            tar -czf "../${EXPORT_NAME}_${VERSION}_Linux.tar.gz" .
            cd ..
          fi

          echo "ğŸ“‹ Archive contents:"
          ls -la *.zip *.tar.gz 2>/dev/null || echo "No archives found"

      - name: ğŸ“ Generate Release Notes
        run: |
          echo "ğŸ“ Generating release notes..."
          VERSION="${{ needs.version-check.outputs.version }}"
          BUILD_NUMBER="${{ github.run_number }}"
          COMMIT_HASH="${{ github.sha }}"
          COMMIT_SHORT=$(echo "$COMMIT_HASH" | cut -c1-8)

          cat > build/RELEASE_NOTES.md << EOF
          # Children of the Singularity - Release $VERSION

          **Build Information:**
          - Version: $VERSION
          - Build Number: $BUILD_NUMBER
          - Commit: $COMMIT_SHORT
          - Build Date: $(date)

          ## Platform Downloads

          | Platform | Download | Notes |
          |----------|----------|--------|
          | Windows | ${EXPORT_NAME}_${VERSION}_Windows.zip | Windows 10+ (64-bit) |
          | macOS | ${EXPORT_NAME}_${VERSION}_macOS.zip | macOS 10.15+ (Universal) |
          | Linux | ${EXPORT_NAME}_${VERSION}_Linux.tar.gz | Linux (64-bit) |

          ## Installation

          ### Windows
          1. Download and extract the Windows zip file
          2. Run \`${EXPORT_NAME}.exe\`

          ### macOS
          1. Download and extract the macOS zip file
          2. Run \`${EXPORT_NAME}.app\`
          3. If blocked by security, right-click and select "Open"

          ### Linux
          1. Download and extract the Linux tar.gz file
          2. Make executable: \`chmod +x ${EXPORT_NAME}.x86_64\`
          3. Run: \`./${EXPORT_NAME}.x86_64\`

          ## Game Features

          - **3D Space Exploration**: Navigate through procedurally populated space zones
          - **Debris Collection**: Collect valuable space debris and artifacts
          - **Space Station Trading**: Interact with modular space stations
          - **Resource Management**: Manage collected resources and ship upgrades
          - **Dynamic Environment**: Real-time debris spawning and despawning system

          ## System Requirements

          - **Minimum**:
            - OS: Windows 10 / macOS 10.15 / Ubuntu 18.04
            - CPU: 2 GHz dual-core processor
            - Memory: 4 GB RAM
            - Graphics: Integrated graphics or dedicated GPU
            - Storage: 500 MB available space

          - **Recommended**:
            - OS: Windows 11 / macOS 12+ / Ubuntu 20.04+
            - CPU: 3 GHz quad-core processor
            - Memory: 8 GB RAM
            - Graphics: Dedicated GPU with 2GB VRAM
            - Storage: 1 GB available space

          ## Controls

          - **WASD** / **Arrow Keys**: Move ship
          - **Mouse**: Camera control
          - **Space**: Collect debris (when near)
          - **Escape**: Pause/Menu

          ## Known Issues

          - Export templates required for building from source
          - Some debris may occasionally flicker during collection

          ## Support

          For issues or feedback, please visit our GitHub repository.

          ---

          *Built with Godot $GODOT_VERSION*
          EOF

      - name: â˜ï¸ Upload to S3 (if configured)
        if: ${{ vars.USE_S3_STORAGE == 'true' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-west-2' }}
          S3_BUCKET_NAME: ${{ vars.S3_BUCKET_NAME || 'children-of-singularity-releases' }}
          BUILD_NUMBER: ${{ github.run_number }}
          COMMIT_HASH: ${{ github.sha }}
        run: |
          # Install AWS CLI
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install

          # Make S3 manager executable
          chmod +x scripts/s3-manager.sh

          # Setup S3 bucket (will skip if exists)
          ./scripts/s3-manager.sh setup

          # Get version from tag or input
          VERSION="${{ needs.version-check.outputs.version }}"

          # Upload release to S3
          echo "ğŸ“¤ Uploading release $VERSION to S3..."
          if ./scripts/s3-manager.sh upload-release "$VERSION" "build/"; then
            echo "âœ… Release uploaded to S3 successfully"

            # Generate download URLs and save to file
            echo "ğŸ”— Generating download URLs..."
            ./scripts/s3-manager.sh get-urls "$VERSION" 604800 > build/s3-download-urls.txt

            echo "ğŸ“‹ S3 Release Information:"
            ./scripts/s3-manager.sh list-releases "$VERSION"
          else
            echo "âŒ Failed to upload to S3"
            exit 1
          fi

      - name: ğŸ“¤ Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-builds
          path: build/
          retention-days: 1

  # Create GitHub Release
  create-release:
    name: ğŸ·ï¸ Create Release
    runs-on: ubuntu-latest
    needs: [version-check, build-game]
    if: needs.version-check.outputs.should_release == 'true'
    steps:
      - name: ğŸ“¥ Download Build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: release-builds
          path: build/

      - name: ğŸ“‹ List Build Contents
        run: |
          echo "ğŸ“‹ Build contents:"
          find build/ -type f -name "*.zip" -o -name "*.tar.gz" -o -name "RELEASE_NOTES.md" | sort

      - name: ğŸ·ï¸ Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.version-check.outputs.version }}
          name: "Children of the Singularity ${{ needs.version-check.outputs.version }}"
          body_path: build/RELEASE_NOTES.md
          draft: false
          prerelease: ${{ needs.version-check.outputs.is_prerelease == 'true' }}
          files: |
            build/*.zip
            build/*.tar.gz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: â˜ï¸ S3 Release Summary (if configured)
        if: ${{ vars.USE_S3_STORAGE == 'true' }}
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ vars.AWS_REGION || 'us-west-2' }}
          S3_BUCKET_NAME: ${{ vars.S3_BUCKET_NAME || 'children-of-singularity-releases' }}
        run: |
          # Install AWS CLI
          curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
          unzip awscliv2.zip
          sudo ./aws/install

          VERSION="${{ needs.version-check.outputs.version }}"

          echo "â˜ï¸ S3 Release Summary:"
          echo "ğŸ“‹ Version: $VERSION"
          echo "ğŸª£ Bucket: $S3_BUCKET_NAME"
          echo "ğŸŒ Region: $AWS_REGION"
          echo ""

          # Show S3 release information
          chmod +x scripts/s3-manager.sh
          if ./scripts/s3-manager.sh check; then
            echo "ğŸ“Š S3 Storage Information:"
            ./scripts/s3-manager.sh storage-info

            echo ""
            echo "ğŸ”— Download URLs (valid for 7 days):"
            ./scripts/s3-manager.sh get-urls "$VERSION" 604800
          else
            echo "âš ï¸ Could not connect to S3"
          fi

      - name: ğŸ‰ Release Summary
        run: |
          echo "ğŸ‰ Release pipeline completed successfully!"
          echo "ğŸ“‹ Release: ${{ needs.version-check.outputs.version }}"
          echo "ğŸ”— Check the releases page for download links"

          if [ "${{ vars.USE_S3_STORAGE }}" = "true" ]; then
            echo "â˜ï¸ S3 storage also available with extended retention"
            echo "ğŸª£ S3 Bucket: ${{ vars.S3_BUCKET_NAME || 'children-of-singularity-releases' }}"
          fi
