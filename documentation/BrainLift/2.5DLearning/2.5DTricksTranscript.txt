a young student asked me how he could create something like that in goodle a game with more or less Tod Graphics so with character sprites but with the ability to move in space and he sent me a solution for game maker which is a 2d engine where you have some code to fake the z-axis which works fine if you're making a very basic game but it's actually quite hard to fake this 3D movement in 2D because you have to essentially write custom physics rewrite all the collisions and to handle dep salting which a 3D engine can do for you and this example I've decided to go with the 3D engine to show a potential way to implement the game here is the 3D World and we're going to see the tricks that make this little scene work some tips you can apply to your own project I'm not going to talk too much about the code because the character movement is quite similar to what you would do in 2D with a kinematic body 2D speaking of which the boxes are static bodies with a collision box so you have a mesh and a collision box here for each of them and the godet the character factor is a kinematic body 2D so we are relying on godo's collisions here physics engine which has a collision shape that is larger than the Sprite what's most important here is that the Collision box is larger than the Sprite on the width and the depth but the height is not as important all that matters is that the Collision shape itself is standing on the ground which is always a bit hard to place here the reason for that is that as long as the character sprite doesn't get through when you jump it doesn't get through the shape that's above it it's fine you will never see it cing or intersecting with 3D meshes but if you make the Collision box too thin like so when you play the game the Sprite will intersect with the world that's the first constraint you have when you create those kinds of games in 3D is that you want to make the Collision box as wide as the character and it's going to collide a bit early with the walls that's why in games that used those kinds of techniques you either had you could not directly collide with the walls in the game or you had some custom rendering or you had characters that were thin and Tall so that you didn't have that large head that could intersect with the world make the character feel it's it's a bit far from the walls the second trick I want to share is how I'm using a Sprite 3D so you can use a Sprite in 3D and gdo and it works similarly to Sprite in the 2D workspace you also have access to an animated Sprite and you can animate the Sprite sheets or the characters like you would do in 2D with an animation player no problem the Sprite 3D has a camera attached to it so it will always be facing the camera if I were to look here you could see however I rotate the character it's always going to be facing the camera and so you want all Sprites to be rotated kind of the same way in your game so if I was to rotate it 45° guess what would happen when I play the game you get an isometric 2.5d game then you need to fix the controls right now they are a bit off good doesn't have automated camera facing meshes I think so if you wanted to have that you would have to code it take the ray that comes from the camera the camera is Vector and have a script on every Sprite in the game that would make it always face the camera it's one line of code but it's worth noting that you don't have a checkbox to do it I believe besides that so the character script we can look at it really quickly if you've worked in 2D and made a 2d game character you will see that the code is quite similar we calculate the direction the character is going to move on the ground by subtracting the result from the get action action Strat calls on the input Singleton we then normalize that vector and we calculate a velocity Vector in 3D using on the x axis and the Z axis the direction on the ground the reason being if I select goet here and I look at the axis can see that the ground is made of the X and z-axis and the y- axis is going to go up here everything that has to do with jumping is going to happen on the y axis of our velocity Vector we then use the move and slide method to move our character based on a velocity and quite important you want to set the floor normal it's a constant here it's a vector pointing up for the is on Flor method to work this method is going to return true or false so it's going to return true if you are standing on some ground on the floor or on some slope when the player presses the jump key it's set to space in this project we set the velocity to a fairly high value the jum force and as long as the character is in the air it's not on the floor at least we are going to subtract a gravity multiplied by Delta a downward acceleration after we move the character if it's colliding on the floor if it touches the floor or it touches some ceiling we set the velocity back to zero the reason we do that both When We Touch the floor or the ceiling is that if we don't reset it when we reach the ceiling the velocity y will be a bit too high and the character will float for a little while against the ceiling I can remove this statement here show you that when you're under the block here if I jump the character gets stuck for a little moment it doesn't bounce of the ceiling well if I add the statement back the is going to bounce and fall back down pretty much instantly so that's it that's the important code in this character and the only code in this project the physics engine is handling all the collisions for us next I want to talk a bit about textures if you import a Sprite by default and use it on a Sprite 3D node it's going to look a little off so I'm going to reset the texture I'm going to use the texture preset let's say because when you import a Sprite I think it'll be set to 2D by default it will look like that little washed out so you want to use the 3D preset and you want to go down and in the flag section of the import tab you want to force srgb you want to force the texture to use the srgb space I don't know exactly why but this fixes the colors in 3D then you might want to have fix Alpha Boulder on you can see it makes a slight difference on the Sprite on the texture it removes that slight Boulder effect that you guess the little bleeding that you get on the outline of the character now one of the advantages of working in 3D is how you can get the Shadows the ability to rotate the camera in space get quite a few advantages like these so anytime you can rotate your directional light to change how the Shadows look so you could have day and night cycles you can use all the effects like in your if you go to your default environment in the game resource which you use to set we have videos on this you use to set all the special effects on the game you can have ambient occlusion as I I'm using uh in the project here as I had on if I go back in the camera view you'll see that we can also use near and far dep of field blur it's linked to the camera's position so in the game as you move the camera the blur will move with the character I want to Note One Thing If I deactivate the blur and go back to the game one limitation if you are working with an ath graphic camera is sometimes by default if it's too close to the character you will start to see the meshes clipping in the game world if I take my camera here and I move it back towards the character going to click on that icon at the top in the toolbar to change the movement to local mode so it's using the camera's rotation and rotating the axis along the camera and so if I move my camera into the box you can see in front and play the game you will see it clipped so you want the camera to be far enough from the character to not clip into the geometry then the camera settings are quite important the camera's projection is set to orthogonal you could use perspective if you want to have a complete 3D game where you can rotate the camera or to have some perspective but if you want the game world to look 2D you will want an alal projection parallel lines they will look parallel on the screen they won't be projected to a vanishing point then you want to tweak the size of the camera the size parameter this is what's going to make the game World small or big it's a sort of zoom level if you want when you are using the orthographic view so you use that to zoom in and out of the game and then you have the clipping planes the near and far geometry how it's going to clip compared to the camera but moving the camera far away from the character will make it not clip in the near plane however for the far plane it will depend on the angle of your camera and the scale of the world I'm using an angle of 30° on the camera so that it always looks a bit down at the world and it doesn't need to catch details that are too far in the distance so you don't have to worry about lods you don't have to worry about some optimization that might be a little tricky so that's how I would work on a 2d game with some depth the main difficulty or challenge you'll face in this kind of project is rendering making everything look 2D in order to do so uh I invite you to look at talks and breakdowns of the art of Diablo 3 three where they used camera facing meshes with textures applied to them and they use quite a few 2D elements and you want to use art like that as much 2D art as possible in your game to make it look like a 2d game if you want if you use 3D meshes throughout your game World unless you have really good painterly textures and very organic modeling you are most likely going to get little bit of a 3D look to it it's a matter of all Direction this is beyond the scope of this tutorial but that said you can find the source code the source project on GitHub there's a link in the description I want to thank you kindly for watching be creative have fun and let's see one another in the next one bye-bye
